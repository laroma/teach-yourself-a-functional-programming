package euler

object ProjectEuler {
  /*
   * Even Fibonacci numbers
   *
   * Each new term in the Fibonacci sequence is generated by adding the previous
   * two terms. By starting with 1 and 2, the first 10 terms will be:
   *
   * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
   *
   * By considering the terms in the Fibonacci sequence whose values do not
   * exceed four million, find the sum of the even-valued terms.
   */
  def problem2(): Int = {
    /*def moreFibosUntilTheMax(fib1: Int, fib2: Int, maxFib: Int): Int = {
      val nextFib = fib1 + fib2
      if(nextFib >= maxFib)
        0
      else if(fib2 % 2 == 0)
        fib2 + moreFibosUntilTheMax(fib2, nextFib, maxFib)
      else
        moreFibosUntilTheMax(fib2, nextFib, maxFib)
    }
    moreFibosUntilTheMax(1, 2, 4000000)*/
    
    lazy val fs: Stream[Int] = 0 #:: 1 #:: fs.zip(fs.tail).map(p => p._1 + p._2)
    fs.view.takeWhile(_ <= 4000000).filter(_ % 2 == 0).sum
  }

  /*
   * Largest palindrome product
   *
   * A palindromic number reads the same both ways. The largest palindrome made
   * from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
   *
   * Find the largest palindrome made from the product of two 3-digit numbers.
   *
   */
  def problem4(): Int = {
    /*
    def getPalindromicNumbah(a: Int, b: Int, max: Int, largest: Int): Int = {
      if (a > max) {
        largest
      } else {
        if (a <= max && b > max) {
          getPalindromicNumbah(a + 1, 100, max, largest)
        } else {
  
          val value = a * b
  
          if (value.toString == value.toString.reverse)
            getPalindromicNumbah(a, b + 1, max, value)
          else
            getPalindromicNumbah(a, b + 1, max, largest)
        }
      }
    }
  
    getPalindromicNumbah(100, 100, 999, 0)
  */
    
    (100 to 999).view.flatMap(i => (i to 999).map(i *)).filter(n => n.toString == n.toString.reverse).max
  }

  /*
   * Special Pythagorean triplet
   *
   * A Pythagorean triplet is a set of three natural numbers, a < b < c, for
   * which, a^2 + b^2 = c^2
   *
   * For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
   *
   * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
   * Find the product abc.
   */
  def problem9(): Int = {
    val limit = (1 to 1000).find(n => n + math.sqrt(n) >= 1000).get
    val rs = for(b <- 2 until limit; a <- 1 until b; c = 1000 - a - b
             if a * a + b * b  == c * c) yield a * b * c
    rs(0)
  }


  /*
   * Maximum path sum I
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *      3
   *     7 4
   *    2 4 6
   *   8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom of the given triangle with 15
   * rows:
   */
  def problem18(triangle: List[List[Int]]): Int = if (triangle.size==1) triangle(0)(0) else problem67(triangle.dropRight(2):+triangle.last.foldLeft(List[Int](),0)((x,xs)=>(x._1:+math.max(x._2,xs),xs))._1.tail.zip(triangle(triangle.size-2)).map(x=>x._1+x._2))

  /*
   * Maximum path sum II
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *    3
   *   7 4
   *  2 4 6
   * 8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom in the given triangle with
   * one-hundred rows.
   *
   * NOTE: This is a much more difficult version of Problem 18. It is not
   * possible to try every route to solve this problem, as there are 2^99
   * altogether! If you could check one trillion (10^12) routes every second it
   * would take over twenty billion years to check them all. There is an
   * efficient algorithm to solve it. ;o)
   */
  def problem67(triangle: List[List[Int]]): Int = if (triangle.size==1) triangle(0)(0) else problem67(triangle.dropRight(2):+triangle.last.foldLeft(List[Int](),0)((x,xs)=>(x._1:+math.max(x._2,xs),xs))._1.tail.zip(triangle(triangle.size-2)).map(x=>x._1+x._2))
}
